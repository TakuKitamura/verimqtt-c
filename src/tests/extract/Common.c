/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -verbose -warn-error +9 -drop WasmSupport -drop C_Endianness -drop C -tmpdir ../out -fsopt --cache_dir -fsopt ../out -no-prefix Main -no-prefix Utils -no-prefix Const -no-prefix Common -no-prefix Publish -no-prefix Connect -no-prefix Disconnect -no-prefix FFI -no-prefix Debug -no-prefix Debug_FFI -o ../mqttPacketParser.out main.fst common.fst const.fst publish.fst connect.fst disconnect.fst ffi.fst debug.fst debug_ffi.fst ffi.c debug_ffi.c callMain.c
  F* version: ad3db6d3
  KreMLin version: 2f843633
 */

#include "Common.h"

uint8_t most_significant_four_bit_to_zero(uint8_t i)
{
  if (i >= (uint8_t)128U)
    return i - (uint8_t)128U;
  else
    return i;
}

uint32_t decodeing_variable_bytes(uint8_t *ptr_for_decoding_packets, uint8_t bytes_length)
{
  uint8_t ptr_for_decoding_packet = (uint8_t)0U;
  uint32_t ptr_for_remaining_length = (uint32_t)0U;
  uint32_t ptr_temp1 = (uint32_t)0U;
  uint32_t ptr_temp2 = (uint32_t)0U;
  uint32_t ptr_temp3 = (uint32_t)0U;
  uint32_t ptr_temp4 = (uint32_t)0U;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)4U; i = i + (uint32_t)1U)
  {
    uint8_t decoding_packet = ptr_for_decoding_packets[i];
    uint8_t b_u8 = most_significant_four_bit_to_zero(decoding_packet);
    uint32_t b_u32 = (uint32_t)b_u8;
    if (i == (uint32_t)0U)
    {
      ptr_temp1 = b_u32 * (uint32_t)1U;
      ptr_for_remaining_length = ptr_temp1;
    }
    else if (i == (uint32_t)1U)
    {
      ptr_temp2 = ptr_temp1 + b_u32 * (uint32_t)128U;
      ptr_for_remaining_length = ptr_temp2;
    }
    else if (i == (uint32_t)2U)
    {
      ptr_temp3 = ptr_temp2 + b_u32 * (uint32_t)128U * (uint32_t)128U;
      ptr_for_remaining_length = ptr_temp3;
    }
    else
    {
      ptr_temp4 = ptr_temp3 + b_u32 * (uint32_t)128U * (uint32_t)128U * (uint32_t)128U;
      ptr_for_remaining_length = ptr_temp4;
    }
  }
  uint32_t remaining_length = ptr_for_remaining_length;
  return remaining_length;
}

struct_variable_length
get_variable_byte(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t now_index,
  bool compare_packet_size
)
{
  uint8_t ptr_for_decoding_packets[4U] = { 0U };
  uint32_t ptr_remaining_length = (uint32_t)0U;
  uint8_t ptr_byte_length = (uint8_t)0U;
  uint32_t ptr_next_start_index = (uint32_t)0U;
  uint32_t loop_last;
  if (packet_size - now_index < (uint32_t)4U)
    loop_last = packet_size;
  else
    loop_last = now_index + (uint32_t)4U;
  for (uint32_t i = now_index; i < loop_last; i = i + (uint32_t)1U)
    if (ptr_byte_length == (uint8_t)0U)
    {
      uint32_t j = i - now_index;
      uint8_t one_byte = packet_data[i];
      ptr_for_decoding_packets[j] = one_byte;
      bool is_end_byte;
      if
      (
        j
        == (uint32_t)0U
        && one_byte <= (uint8_t)0x7FU
        || j >= (uint32_t)1U && one_byte >= (uint8_t)0x01U && one_byte <= (uint8_t)0x7FU
      )
        is_end_byte = true;
      else
        is_end_byte = false;
      if (is_end_byte)
      {
        uint8_t bytes_length_u8 = (uint8_t)(j + (uint32_t)1U);
        uint32_t
        untrust_remaining_length =
          decodeing_variable_bytes(ptr_for_decoding_packets,
            bytes_length_u8);
        uint32_t untrust_packet_last_index = untrust_remaining_length + i;
        uint32_t packet_last_index = packet_size - (uint32_t)1U;
        bool valid_remaining_length;
        if (now_index == (uint32_t)1U)
          valid_remaining_length = untrust_packet_last_index == packet_last_index;
        else
          valid_remaining_length = untrust_packet_last_index <= packet_last_index;
        if (valid_remaining_length || !compare_packet_size)
        {
          ptr_remaining_length = untrust_remaining_length;
          ptr_byte_length = bytes_length_u8;
          uint32_t ite;
          if (loop_last == packet_size)
            ite = packet_size - (uint32_t)1U;
          else
            ite = now_index + (uint32_t)bytes_length_u8;
          ptr_next_start_index = ite;
        }
      }
    }
  uint32_t remaining_length = ptr_remaining_length;
  uint8_t byte_length = ptr_byte_length;
  uint32_t next_start_index = ptr_next_start_index;
  if (byte_length == (uint8_t)0U)
    return
      (
        (struct_variable_length){
          .have_error = true,
          .variable_length_value = (uint32_t)0U,
          .next_start_index = (uint32_t)0U
        }
      );
  else
    return
      (
        (struct_variable_length){
          .have_error = false,
          .variable_length_value = remaining_length,
          .next_start_index = next_start_index
        }
      );
}

uint8_t get_message_type(uint8_t message_type_bits)
{
  if (message_type_bits < (uint8_t)1U || message_type_bits > (uint8_t)15U)
    return max_u8;
  else
    return message_type_bits;
}

struct_fixed_header_constant
get_struct_fixed_header_constant_except_publish(uint8_t message_type)
{
  if (message_type == define_mqtt_control_packet_CONNECT)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_CONNECT,
          .message_name_constant = define_mqtt_control_packet_CONNECT_label,
          .flags_constant = {
            .flag = define_flag_CONNECT,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_CONNACK)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_CONNACK,
          .message_name_constant = define_mqtt_control_packet_CONNACK_label,
          .flags_constant = {
            .flag = define_flag_CONNACK,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_PUBACK)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_PUBACK,
          .message_name_constant = define_mqtt_control_packet_PUBACK_label,
          .flags_constant = {
            .flag = define_flag_PUBACK,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_PUBREC)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_PUBREC,
          .message_name_constant = define_mqtt_control_packet_PUBREC_label,
          .flags_constant = {
            .flag = define_flag_PUBREC,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_PUBREL)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_PUBREL,
          .message_name_constant = define_mqtt_control_packet_PUBREL_label,
          .flags_constant = {
            .flag = define_flag_PUBREL,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_PUBCOMP)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_PUBCOMP,
          .message_name_constant = define_mqtt_control_packet_PUBCOMP_label,
          .flags_constant = {
            .flag = define_flag_PUBCOMP,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_SUBSCRIBE)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_SUBSCRIBE,
          .message_name_constant = define_mqtt_control_packet_SUBSCRIBE_label,
          .flags_constant = {
            .flag = define_flag_SUBSCRIBE,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_SUBACK)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_SUBACK,
          .message_name_constant = define_mqtt_control_packet_SUBACK_label,
          .flags_constant = {
            .flag = define_flag_SUBACK,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_UNSUBSCRIBE)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_UNSUBSCRIBE,
          .message_name_constant = define_mqtt_control_packet_UNSUBSCRIBE_label,
          .flags_constant = {
            .flag = define_flag_UNSUBSCRIBE,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_UNSUBACK)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_UNSUBACK,
          .message_name_constant = define_mqtt_control_packet_UNSUBACK_label,
          .flags_constant = {
            .flag = define_flag_UNSUBACK,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_PINGREQ)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_PINGREQ,
          .message_name_constant = define_mqtt_control_packet_PINGREQ_label,
          .flags_constant = {
            .flag = define_flag_PINGREQ,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_PINGRESP)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_PINGRESP,
          .message_name_constant = define_mqtt_control_packet_PINGRESP_label,
          .flags_constant = {
            .flag = define_flag_PINGRESP,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else if (message_type == define_mqtt_control_packet_DISCONNECT)
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_DISCONNECT,
          .message_name_constant = define_mqtt_control_packet_DISCONNECT_label,
          .flags_constant = {
            .flag = define_flag_DISCONNECT,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
  else
    return
      (
        (struct_fixed_header_constant){
          .message_type_constant = define_mqtt_control_packet_AUTH,
          .message_name_constant = define_mqtt_control_packet_AUTH_label,
          .flags_constant = {
            .flag = define_flag_AUTH,
            .dup_flag = max_u8,
            .qos_flag = max_u8,
            .retain_flag = max_u8
          }
        }
      );
}

struct_fixed_header error_struct_fixed_header(struct_error_struct error_struct)
{
  uint8_t empty_buffer = (uint8_t)0U;
  return
    (
      (struct_fixed_header){
        .message_type = max_u8,
        .message_name = "",
        .flags = { .flag = max_u8, .dup_flag = max_u8, .qos_flag = max_u8, .retain_flag = max_u8 },
        .remaining_length = (uint32_t)0U,
        .connect = {
          .protocol_name = "", .protocol_version = max_u8,
          .flags = {
            .connect_flag = max_u8, .user_name = max_u8, .password = max_u8, .will_retain = max_u8,
            .will_qos = max_u8, .will_flag = max_u8, .clean_start = max_u8
          }, .keep_alive = (uint16_t)0U,
          .connect_id = {
            .utf8_string_length = (uint16_t)0U,
            .utf8_string_value = &empty_buffer,
            .utf8_string_status_code = (uint8_t)1U,
            .utf8_next_start_index = (uint32_t)0U
          },
          .will = {
            .connect_will_property = property_struct_base,
            .connect_will_topic_name = {
              .utf8_string_length = (uint16_t)0U,
              .utf8_string_value = &empty_buffer,
              .utf8_string_status_code = (uint8_t)1U,
              .utf8_next_start_index = (uint32_t)0U
            },
            .connect_will_payload = {
              .is_valid_binary_data = false,
              .binary_length = (uint16_t)0U,
              .binary_value = &empty_buffer,
              .binary_next_start_index = (uint32_t)0U
            },
            .user_name_or_password_next_start_index = (uint32_t)0U
          },
          .user_name = {
            .utf8_string_length = (uint16_t)0U,
            .utf8_string_value = &empty_buffer,
            .utf8_string_status_code = (uint8_t)1U,
            .utf8_next_start_index = (uint32_t)0U
          },
          .password = {
            .is_valid_binary_data = false,
            .binary_length = (uint16_t)0U,
            .binary_value = &empty_buffer,
            .binary_next_start_index = (uint32_t)0U
          }
        },
        .publish = {
          .topic_length = (uint32_t)0U,
          .topic_name = "",
          .packet_identifier = max_u16,
          .payload = {
            .is_valid_payload = false,
            .payload_value = &empty_buffer,
            .payload_length = (uint32_t)0U
          }
        },
        .disconnect = { .disconnect_reason_code = max_u8, .disconnect_reason_code_name = "" },
        .property = property_struct_base,
        .error = error_struct
      }
    );
}

uint8_t slice_byte(uint8_t byte, uint8_t a, uint8_t b)
{
  uint8_t for_mask_temp1;
  if ((uint32_t)0U == (uint32_t)a)
    for_mask_temp1 = (uint8_t)0b11111111U;
  else if ((uint32_t)1U == (uint32_t)a)
    for_mask_temp1 = (uint8_t)0b01111111U;
  else if ((uint32_t)2U == (uint32_t)a)
    for_mask_temp1 = (uint8_t)0b00111111U;
  else if ((uint32_t)3U == (uint32_t)a)
    for_mask_temp1 = (uint8_t)0b00011111U;
  else if ((uint32_t)4U == (uint32_t)a)
    for_mask_temp1 = (uint8_t)0b00001111U;
  else if ((uint32_t)5U == (uint32_t)a)
    for_mask_temp1 = (uint8_t)0b00000111U;
  else if ((uint32_t)6U == (uint32_t)a)
    for_mask_temp1 = (uint8_t)0b00000011U;
  else
    for_mask_temp1 = (uint8_t)0b00000001U;
  uint8_t for_mask_temp2;
  if ((uint32_t)1U == (uint32_t)b)
    for_mask_temp2 = (uint8_t)0b10000000U;
  else if ((uint32_t)2U == (uint32_t)b)
    for_mask_temp2 = (uint8_t)0b11000000U;
  else if ((uint32_t)3U == (uint32_t)b)
    for_mask_temp2 = (uint8_t)0b11100000U;
  else if ((uint32_t)4U == (uint32_t)b)
    for_mask_temp2 = (uint8_t)0b11110000U;
  else if ((uint32_t)5U == (uint32_t)b)
    for_mask_temp2 = (uint8_t)0b11111000U;
  else if ((uint32_t)6U == (uint32_t)b)
    for_mask_temp2 = (uint8_t)0b11111100U;
  else if ((uint32_t)7U == (uint32_t)b)
    for_mask_temp2 = (uint8_t)0b11111110U;
  else
    for_mask_temp2 = (uint8_t)0b11111111U;
  uint8_t mask = for_mask_temp1 & for_mask_temp2;
  return (byte & mask) >> (uint32_t)8U - (uint32_t)b;
}

uint8_t get_dup_flag(uint8_t fixed_header_first_one_byte)
{
  uint8_t dup_flag_bits = slice_byte(fixed_header_first_one_byte, (uint8_t)4U, (uint8_t)5U);
  if (dup_flag_bits > (uint8_t)1U)
    return max_u8;
  else
    return dup_flag_bits;
}

uint8_t get_qos_flag(uint8_t fixed_header_first_one_byte)
{
  uint8_t qos_flag_bits = slice_byte(fixed_header_first_one_byte, (uint8_t)5U, (uint8_t)7U);
  if (qos_flag_bits > (uint8_t)2U)
    return max_u8;
  else
    return qos_flag_bits;
}

uint8_t get_retain_flag(uint8_t fixed_header_first_one_byte)
{
  uint8_t retain_flag_bits = slice_byte(fixed_header_first_one_byte, (uint8_t)7U, (uint8_t)8U);
  if (retain_flag_bits > (uint8_t)1U)
    return max_u8;
  else
    return retain_flag_bits;
}

uint8_t get_flag(uint8_t message_type, uint8_t fixed_header_first_one_byte)
{
  uint8_t v1 = slice_byte(fixed_header_first_one_byte, (uint8_t)4U, (uint8_t)8U);
  if
  (
    message_type
    == define_mqtt_control_packet_PUBREL
    || message_type == define_mqtt_control_packet_SUBSCRIBE
    || message_type == define_mqtt_control_packet_UNSUBSCRIBE
  )
    if (v1 != (uint8_t)0b0010U)
      return max_u8;
    else
      return v1;
  else if (message_type == define_mqtt_control_packet_PUBLISH)
  {
    uint8_t qos_flag = get_qos_flag(fixed_header_first_one_byte);
    if (qos_flag == (uint8_t)3U)
      return max_u8;
    else
      return v1;
  }
  else if (v1 != (uint8_t)0b0000U)
    return max_u8;
  else
    return v1;
}

struct_share_common_data_check
share_common_data_check(uint8_t *packet_data, uint32_t packet_size)
{
  uint8_t first_one_byte = packet_data[0U];
  uint8_t message_type_bits = slice_byte(first_one_byte, (uint8_t)0U, (uint8_t)4U);
  uint8_t message_type = get_message_type(message_type_bits);
  uint8_t flag = get_flag(message_type, first_one_byte);
  struct_variable_length
  variable_length = get_variable_byte(packet_data, packet_size, (uint32_t)1U, true);
  uint32_t remaining_length = variable_length.variable_length_value;
  uint32_t next_start_index = variable_length.next_start_index;
  bool is_share_error = variable_length.have_error || message_type == max_u8 || flag == max_u8;
  if (is_share_error)
  {
    struct_error_struct error_struct;
    if (variable_length.have_error)
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_remaining_length_invalid_code,
            .message = define_error_remaining_length_invalid
          }
        );
    else if (message_type == max_u8)
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_message_type_invalid_code,
            .message = define_error_message_type_invalid
          }
        );
    else
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_flag_invalid_code,
            .message = define_error_flag_invalid
          }
        );
    struct_fixed_header error = error_struct_fixed_header(error_struct);
    return
      (
        (struct_share_common_data_check){
          .share_common_data_have_error = is_share_error,
          .share_common_data_error = error,
          .share_common_data = {
            .common_packet_data = packet_data, .common_packet_size = packet_size,
            .common_message_type = max_u8, .common_flag = max_u8,
            .common_remaining_length = (uint32_t)0U, .common_next_start_index = (uint32_t)0U
          }
        }
      );
  }
  else
  {
    struct_error_struct error_struct = { .code = define_no_error_code, .message = "" };
    struct_fixed_header no_error = error_struct_fixed_header(error_struct);
    struct_share_common_data
    share_common_data =
      {
        .common_packet_data = packet_data, .common_packet_size = packet_size,
        .common_message_type = message_type, .common_flag = flag,
        .common_remaining_length = remaining_length, .common_next_start_index = next_start_index
      };
    return
      (
        (struct_share_common_data_check){
          .share_common_data_have_error = is_share_error,
          .share_common_data_error = no_error,
          .share_common_data = share_common_data
        }
      );
  }
}

uint8_t get_property_type_id(uint8_t property_id)
{
  if
  (
    property_id
    == (uint8_t)0x01U
    || property_id == (uint8_t)0x17U
    || property_id == (uint8_t)0x19U
    || property_id == (uint8_t)0x24U
    || property_id == (uint8_t)0x25U
    || property_id == (uint8_t)0x28U
    || property_id == (uint8_t)0x29U
    || property_id == (uint8_t)0x2AU
  )
    return (uint8_t)0x01U;
  else if
  (
    property_id
    == (uint8_t)0x13U
    || property_id == (uint8_t)0x21U
    || property_id == (uint8_t)0x22U
    || property_id == (uint8_t)0x23U
  )
    return (uint8_t)0x02U;
  else if
  (
    property_id
    == (uint8_t)0x02U
    || property_id == (uint8_t)0x11U
    || property_id == (uint8_t)0x18U
    || property_id == (uint8_t)0x27U
  )
    return (uint8_t)0x03U;
  else if
  (
    property_id
    == (uint8_t)0x03U
    || property_id == (uint8_t)0x08U
    || property_id == (uint8_t)0x12U
    || property_id == (uint8_t)0x15U
    || property_id == (uint8_t)0x1AU
    || property_id == (uint8_t)0x1CU
    || property_id == (uint8_t)0x1FU
  )
    return (uint8_t)0x04U;
  else if (property_id == (uint8_t)0x0BU)
    return (uint8_t)0x05U;
  else if (property_id == (uint8_t)0x09U || property_id == (uint8_t)0x16U)
    return (uint8_t)0x06U;
  else if (property_id == (uint8_t)0x26U)
    return (uint8_t)0x07U;
  else
    return max_u8;
}

uint16_t get_two_byte_integer_u8_to_u16(uint8_t msb_u8, uint8_t lsb_u8)
{
  uint16_t msb_u16 = (uint16_t)msb_u8;
  uint16_t lsb_u16 = (uint16_t)lsb_u8;
  uint16_t two_byte_integer = msb_u16 << (uint32_t)8U | lsb_u16;
  return two_byte_integer;
}

uint32_t
get_four_byte_integer(uint8_t mmsb_u8, uint8_t msb_u8, uint8_t lsb_u8, uint8_t llsb_u8)
{
  uint32_t mmsb_u32 = (uint32_t)mmsb_u8;
  uint32_t msb_u32 = (uint32_t)msb_u8;
  uint32_t lsb_u32 = (uint32_t)lsb_u8;
  uint32_t llsb_u32 = (uint32_t)llsb_u8;
  return
    mmsb_u32
    << (uint32_t)24U
    | msb_u32 << (uint32_t)16U
    | lsb_u32 << (uint32_t)8U | llsb_u32;
}

struct_payload
get_payload(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t payload_start_index,
  uint32_t payload_end_index
)
{
  uint32_t payload_length = payload_end_index - payload_start_index + (uint32_t)1U;
  uint8_t *ptr_payload_u8 = packet_data + payload_start_index;
  return
    (
      (struct_payload){
        .is_valid_payload = true,
        .payload_value = ptr_payload_u8,
        .payload_length = payload_length
      }
    );
}

struct_property_type
parse_property_two_byte_integer(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t property_value_start_index
)
{
  uint8_t msb_u8 = packet_data[property_value_start_index];
  uint8_t lsb_u8 = packet_data[property_value_start_index + (uint32_t)1U];
  uint16_t two_byte_integer = get_two_byte_integer_u8_to_u16(msb_u8, lsb_u8);
  uint16_t two_byte_integer_struct = two_byte_integer;
  struct_property_type b = property_struct_type_base;
  return
    (
      (struct_property_type){
        .one_byte_integer_struct = b.one_byte_integer_struct,
        .two_byte_integer_struct = two_byte_integer_struct,
        .four_byte_integer_struct = b.four_byte_integer_struct,
        .utf8_encoded_string_struct = {
          .utf8_string_length = b.utf8_encoded_string_struct.utf8_string_length,
          .utf8_string_value = b.utf8_encoded_string_struct.utf8_string_value,
          .utf8_string_status_code = b.utf8_encoded_string_struct.utf8_string_status_code,
          .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
        },
        .variable_byte_integer_struct = b.variable_byte_integer_struct,
        .binary_data_struct = {
          .is_valid_binary_data = b.binary_data_struct.is_valid_binary_data,
          .binary_length = b.binary_data_struct.binary_length,
          .binary_value = b.binary_data_struct.binary_value,
          .binary_next_start_index = b.binary_data_struct.binary_next_start_index
        },
        .utf8_string_pair_struct = {
          .utf8_string_pair_key = {
            .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_length,
            .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_value,
            .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_status_code,
            .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
          },
          .utf8_string_pair_value = {
            .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_length,
            .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_value,
            .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_status_code,
            .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
          }
        },
        .property_type_error = define_struct_property_no_error
      }
    );
}

struct_property_type
parse_property_four_byte_integer(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t property_value_start_index
)
{
  uint8_t mmsb_u8 = packet_data[property_value_start_index];
  uint8_t msb_u8 = packet_data[property_value_start_index + (uint32_t)1U];
  uint8_t lsb_u8 = packet_data[property_value_start_index + (uint32_t)2U];
  uint8_t llsb_u8 = packet_data[property_value_start_index + (uint32_t)3U];
  uint32_t four_byte_integer = get_four_byte_integer(mmsb_u8, msb_u8, lsb_u8, llsb_u8);
  uint32_t four_byte_integer_struct = four_byte_integer;
  struct_property_type b = property_struct_type_base;
  return
    (
      (struct_property_type){
        .one_byte_integer_struct = b.one_byte_integer_struct,
        .two_byte_integer_struct = b.two_byte_integer_struct,
        .four_byte_integer_struct = four_byte_integer_struct,
        .utf8_encoded_string_struct = {
          .utf8_string_length = b.utf8_encoded_string_struct.utf8_string_length,
          .utf8_string_value = b.utf8_encoded_string_struct.utf8_string_value,
          .utf8_string_status_code = b.utf8_encoded_string_struct.utf8_string_status_code,
          .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
        },
        .variable_byte_integer_struct = b.variable_byte_integer_struct,
        .binary_data_struct = {
          .is_valid_binary_data = b.binary_data_struct.is_valid_binary_data,
          .binary_length = b.binary_data_struct.binary_length,
          .binary_value = b.binary_data_struct.binary_value,
          .binary_next_start_index = b.binary_data_struct.binary_next_start_index
        },
        .utf8_string_pair_struct = {
          .utf8_string_pair_key = {
            .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_length,
            .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_value,
            .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_status_code,
            .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
          },
          .utf8_string_pair_value = {
            .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_length,
            .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_value,
            .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_status_code,
            .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
          }
        },
        .property_type_error = define_struct_property_no_error
      }
    );
}

struct_property_type
parse_property_one_byte_integer(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t property_value_start_index
)
{
  uint8_t one_byte_integer = packet_data[property_value_start_index];
  uint8_t one_byte_integer_struct = one_byte_integer;
  struct_property_type b = property_struct_type_base;
  return
    (
      (struct_property_type){
        .one_byte_integer_struct = one_byte_integer_struct,
        .two_byte_integer_struct = b.two_byte_integer_struct,
        .four_byte_integer_struct = b.four_byte_integer_struct,
        .utf8_encoded_string_struct = {
          .utf8_string_length = b.utf8_encoded_string_struct.utf8_string_length,
          .utf8_string_value = b.utf8_encoded_string_struct.utf8_string_value,
          .utf8_string_status_code = b.utf8_encoded_string_struct.utf8_string_status_code,
          .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
        },
        .variable_byte_integer_struct = b.variable_byte_integer_struct,
        .binary_data_struct = {
          .is_valid_binary_data = b.binary_data_struct.is_valid_binary_data,
          .binary_length = b.binary_data_struct.binary_length,
          .binary_value = b.binary_data_struct.binary_value,
          .binary_next_start_index = b.binary_data_struct.binary_next_start_index
        },
        .utf8_string_pair_struct = {
          .utf8_string_pair_key = {
            .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_length,
            .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_value,
            .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_status_code,
            .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
          },
          .utf8_string_pair_value = {
            .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_length,
            .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_value,
            .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_status_code,
            .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
          }
        },
        .property_type_error = define_struct_property_no_error
      }
    );
}

struct_property_type
parse_property_variable_byte_integer(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t property_value_start_index
)
{
  struct_variable_length
  variable_length =
    get_variable_byte(packet_data,
      packet_size,
      property_value_start_index,
      false);
  uint32_t property_variable_value = variable_length.variable_length_value;
  uint32_t variable_value_struct = property_variable_value;
  struct_property_type b = property_struct_type_base;
  struct_property_error ite;
  if (variable_length.have_error)
    ite = define_struct_property_variable_integer_error;
  else
    ite = define_struct_property_no_error;
  struct_property_type
  property_struct_type_base1 =
    {
      .one_byte_integer_struct = b.one_byte_integer_struct,
      .two_byte_integer_struct = b.two_byte_integer_struct,
      .four_byte_integer_struct = b.four_byte_integer_struct,
      .utf8_encoded_string_struct = {
        .utf8_string_length = b.utf8_encoded_string_struct.utf8_string_length,
        .utf8_string_value = b.utf8_encoded_string_struct.utf8_string_value,
        .utf8_string_status_code = b.utf8_encoded_string_struct.utf8_string_status_code,
        .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
      }, .variable_byte_integer_struct = variable_value_struct,
      .binary_data_struct = {
        .is_valid_binary_data = b.binary_data_struct.is_valid_binary_data,
        .binary_length = b.binary_data_struct.binary_length,
        .binary_value = b.binary_data_struct.binary_value,
        .binary_next_start_index = b.binary_data_struct.binary_next_start_index
      },
      .utf8_string_pair_struct = {
        .utf8_string_pair_key = {
          .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_length,
          .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_value,
          .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_status_code,
          .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
        },
        .utf8_string_pair_value = {
          .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_length,
          .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_value,
          .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_status_code,
          .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
        }
      }, .property_type_error = ite
    };
  return property_struct_type_base1;
}

struct_binary_data
get_binary(uint8_t *packet_data, uint32_t packet_size, uint32_t binary_start_index)
{
  uint8_t binary_length_msb_u8 = packet_data[binary_start_index];
  uint8_t binary_length_lsb_u8 = packet_data[binary_start_index + (uint32_t)1U];
  uint16_t
  binary_length = get_two_byte_integer_u8_to_u16(binary_length_msb_u8, binary_length_lsb_u8);
  uint32_t payload_start_index = binary_start_index + (uint32_t)2U;
  uint16_t for_end_index_offset;
  if (binary_length == (uint16_t)0U)
    for_end_index_offset = (uint16_t)0U;
  else
    for_end_index_offset = binary_length - (uint16_t)1U;
  uint64_t payload_start_index_u64 = (uint64_t)payload_start_index;
  uint64_t for_end_index_offset_u64 = (uint64_t)for_end_index_offset;
  uint64_t untrust_payload_end_index_u64 = payload_start_index_u64 + for_end_index_offset_u64;
  uint32_t untrust_payload_end_index_u32 = (uint32_t)untrust_payload_end_index_u64;
  bool
  is_valid_binary_data =
    untrust_payload_end_index_u64
    < (uint64_t)(max_packet_size - (uint32_t)1U)
    && payload_start_index <= untrust_payload_end_index_u32;
  uint8_t empty_buffer = (uint8_t)0U;
  if (is_valid_binary_data)
  {
    uint32_t payload_end_index = untrust_payload_end_index_u32;
    struct_payload
    payload_struct = get_payload(packet_data, packet_size, payload_start_index, payload_end_index);
    return
      (
        (struct_binary_data){
          .is_valid_binary_data = true,
          .binary_length = binary_length,
          .binary_value = payload_struct.payload_value,
          .binary_next_start_index = payload_end_index + (uint32_t)1U
        }
      );
  }
  else
    return
      (
        (struct_binary_data){
          .is_valid_binary_data = false,
          .binary_length = (uint16_t)0U,
          .binary_value = &empty_buffer,
          .binary_next_start_index = (uint32_t)0U
        }
      );
}

struct_property_type
parse_property_binary(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t property_value_start_index
)
{
  struct_binary_data
  binary_data_struct = get_binary(packet_data, packet_size, property_value_start_index);
  struct_property_type b = property_struct_type_base;
  return
    (
      (struct_property_type){
        .one_byte_integer_struct = b.one_byte_integer_struct,
        .two_byte_integer_struct = b.two_byte_integer_struct,
        .four_byte_integer_struct = b.four_byte_integer_struct,
        .utf8_encoded_string_struct = {
          .utf8_string_length = b.utf8_encoded_string_struct.utf8_string_length,
          .utf8_string_value = b.utf8_encoded_string_struct.utf8_string_value,
          .utf8_string_status_code = b.utf8_encoded_string_struct.utf8_string_status_code,
          .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
        },
        .variable_byte_integer_struct = b.variable_byte_integer_struct,
        .binary_data_struct = binary_data_struct,
        .utf8_string_pair_struct = {
          .utf8_string_pair_key = {
            .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_length,
            .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_value,
            .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_status_code,
            .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
          },
          .utf8_string_pair_value = {
            .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_length,
            .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_value,
            .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_status_code,
            .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
          }
        },
        .property_type_error = define_struct_property_no_error
      }
    );
}

struct_is_valid_utf8_ready
is_valid_utf8_ready(uint8_t *packet_data, uint32_t packet_size, uint32_t i)
{
  bool ptr_is_malformed_utf8 = false;
  uint8_t ptr_codelen = (uint8_t)0U;
  uint16_t ptr_codepoint = (uint16_t)0U;
  uint8_t one_byte;
  if (i >= packet_size)
    one_byte = (uint8_t)0U;
  else
    one_byte = packet_data[i];
  if (one_byte == (uint8_t)0U)
    ptr_is_malformed_utf8 = true;
  else if (one_byte <= (uint8_t)0x7fU)
  {
    ptr_codelen = (uint8_t)1U;
    ptr_codepoint = (uint16_t)one_byte;
  }
  else if ((one_byte & (uint8_t)0xE0U) == (uint8_t)0xC0U)
    if (one_byte == (uint8_t)0xC0U || one_byte == (uint8_t)0xC1U)
      ptr_is_malformed_utf8 = true;
    else
    {
      ptr_codelen = (uint8_t)2U;
      ptr_codepoint = (uint16_t)(one_byte & (uint8_t)0x1FU);
    }
  else if ((one_byte & (uint8_t)0xF0U) == (uint8_t)0xE0U)
  {
    ptr_codelen = (uint8_t)3U;
    ptr_codepoint = (uint16_t)(one_byte & (uint8_t)0x0FU);
  }
  else if ((one_byte & (uint8_t)0xF8U) == (uint8_t)0xF0U)
    if (one_byte > (uint8_t)0xF4U)
      ptr_is_malformed_utf8 = true;
    else
    {
      ptr_codelen = (uint8_t)4U;
      ptr_codepoint = (uint16_t)(one_byte & (uint8_t)0x07U);
    }
  else
    ptr_is_malformed_utf8 = true;
  bool is_malformed_utf8 = ptr_is_malformed_utf8;
  uint8_t codelen = ptr_codelen;
  uint16_t codepoint = ptr_codepoint;
  struct_is_valid_utf8_ready
  is_valid_utf8_ready_struct =
    {
      .ready_is_malformed_utf8 = is_malformed_utf8,
      .ready_codelen = codelen,
      .ready_codepoint = codepoint
    };
  return is_valid_utf8_ready_struct;
}

bool
is_valid_utf8(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t utf8_encoded_string_entity_start_index,
  uint32_t utf8_encoded_string_entity_end_index,
  uint32_t utf8_encoded_string_end_index
)
{
  bool ptr_is_malformed_utf8 = false;
  uint8_t ptr_codelen = (uint8_t)0U;
  uint16_t ptr_codepoint = (uint16_t)0U;
  uint32_t ptr_i = utf8_encoded_string_entity_start_index;
  if (utf8_encoded_string_entity_start_index < utf8_encoded_string_entity_end_index)
    for
    (uint32_t
      i0 = utf8_encoded_string_entity_start_index;
      i0
      < utf8_encoded_string_entity_end_index;
      i0 = i0 + (uint32_t)1U)
    {
      uint32_t i0 = ptr_i;
      bool is_malformed_utf8 = ptr_is_malformed_utf8;
      if (!(i0 >= utf8_encoded_string_end_index + (uint32_t)1U || is_malformed_utf8))
      {
        struct_is_valid_utf8_ready
        is_valid_utf8_ready_struct = is_valid_utf8_ready(packet_data, packet_size, i0);
        ptr_is_malformed_utf8 = is_valid_utf8_ready_struct.ready_is_malformed_utf8;
        ptr_codelen = is_valid_utf8_ready_struct.ready_codelen;
        ptr_codepoint = is_valid_utf8_ready_struct.ready_codepoint;
        uint8_t codelen_u8 = ptr_codelen;
        uint32_t codelen_u32 = (uint32_t)codelen_u8;
        if
        (
          utf8_encoded_string_end_index
          + (uint32_t)1U
          < codelen_u32
          || i0 == utf8_encoded_string_end_index + (uint32_t)1U - codelen_u32 + (uint32_t)1U
        )
          ptr_is_malformed_utf8 = true;
        else
        {
          uint8_t last_u8;
          if (codelen_u8 >= (uint8_t)1U)
            last_u8 = codelen_u8 - (uint8_t)1U;
          else
          {
            ptr_is_malformed_utf8 = true;
            last_u8 = (uint8_t)0U;
          }
          uint32_t last_u32 = (uint32_t)last_u8;
          for (uint32_t i = (uint32_t)0U; i < last_u32; i = i + (uint32_t)1U)
          {
            uint32_t countup_i = ptr_i + (uint32_t)1U;
            uint32_t ite;
            if (countup_i < max_packet_size)
              ite = countup_i;
            else
            {
              ptr_is_malformed_utf8 = true;
              ite = (uint32_t)0U;
            }
            ptr_i = ite;
            uint32_t ii = ptr_i;
            uint8_t next_one_byte;
            if (ii < packet_size)
              next_one_byte = packet_data[ii];
            else
            {
              ptr_is_malformed_utf8 = true;
              next_one_byte = (uint8_t)0U;
            }
            if (!((next_one_byte & (uint8_t)0xC0U) == (uint8_t)0x80U))
              ptr_is_malformed_utf8 = true;
            else
            {
              uint16_t next_one_byte_u16 = (uint16_t)next_one_byte;
              ptr_codepoint = ptr_codepoint << (uint32_t)6U | next_one_byte_u16 & (uint16_t)0x3FU;
            }
          }
          uint16_t codepoint = ptr_codepoint;
          if (codepoint >= (uint16_t)0xD800U && codepoint <= (uint16_t)0xDFFFU)
            ptr_is_malformed_utf8 = true;
          uint16_t codepoint_u16 = codepoint;
          uint32_t codepoint_u32 = (uint32_t)codepoint_u16;
          if (codelen_u8 == (uint8_t)3U && codepoint < (uint16_t)0x0800U)
            ptr_is_malformed_utf8 = true;
          else if
          (
            codelen_u8
            == (uint8_t)4U
            && (codepoint_u32 < (uint32_t)0x10000U || codepoint_u32 > (uint32_t)0x10FFFFU)
          )
            ptr_is_malformed_utf8 = true;
          if (codepoint >= (uint16_t)0xFDD0U && codepoint <= (uint16_t)0xFDEFU)
            ptr_is_malformed_utf8 = true;
          if
          (
            (codepoint & (uint16_t)0xFFFFU)
            == (uint16_t)0xFFFEU
            || (codepoint & (uint16_t)0xFFFFU) == (uint16_t)0xFFFFU
          )
            ptr_is_malformed_utf8 = true;
          if
          (
            codepoint
            <= (uint16_t)0x001FU
            || codepoint >= (uint16_t)0x007FU && codepoint <= (uint16_t)0x009FU
          )
            ptr_is_malformed_utf8 = true;
        }
        uint32_t countup_i = ptr_i + (uint32_t)1U;
        uint32_t ite;
        if (countup_i < max_packet_size)
          ite = countup_i;
        else
        {
          ptr_is_malformed_utf8 = true;
          ite = (uint32_t)0U;
        }
        ptr_i = ite;
      }
    }
  else
    ptr_is_malformed_utf8 = true;
  bool is_malformed_utf8 = ptr_is_malformed_utf8;
  return is_malformed_utf8;
}

struct_utf8_string
is_valid_utf8_encoded_string(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t utf8_encoded_string_start_index,
  uint16_t utf8_encoded_string_length
)
{
  uint32_t
  utf8_encoded_string_entity_start_index = utf8_encoded_string_start_index + (uint32_t)2U;
  uint32_t
  utf8_encoded_string_end_index =
    utf8_encoded_string_start_index
    + (uint32_t)utf8_encoded_string_length
    + (uint32_t)1U;
  bool ptr_is_malformed_utf8_encoded_string = false;
  uint8_t empty_buffer = (uint8_t)0U;
  uint32_t utf8_encoded_string_entity_end_index;
  if (utf8_encoded_string_end_index < max_packet_size - (uint32_t)1U)
    utf8_encoded_string_entity_end_index = utf8_encoded_string_end_index + (uint32_t)1U;
  else
  {
    ptr_is_malformed_utf8_encoded_string = true;
    utf8_encoded_string_entity_end_index = utf8_encoded_string_entity_start_index;
  }
  bool
  is_malformed_utf8 =
    is_valid_utf8(packet_data,
      packet_size,
      utf8_encoded_string_entity_start_index,
      utf8_encoded_string_entity_end_index,
      utf8_encoded_string_end_index);
  bool temp = ptr_is_malformed_utf8_encoded_string;
  ptr_is_malformed_utf8_encoded_string = is_malformed_utf8 || temp;
  uint8_t *utf8_value;
  if (utf8_encoded_string_entity_start_index <= packet_size)
    utf8_value = packet_data + utf8_encoded_string_entity_start_index;
  else
  {
    ptr_is_malformed_utf8_encoded_string = true;
    utf8_value = &empty_buffer;
  }
  bool temp1 = ptr_is_malformed_utf8_encoded_string;
  uint8_t ite;
  if (temp1)
    ite = (uint8_t)1U;
  else
    ite = (uint8_t)0U;
  struct_utf8_string
  utf8_encoded_string_struct =
    {
      .utf8_string_length = utf8_encoded_string_length,
      .utf8_string_value = utf8_value,
      .utf8_string_status_code = ite,
      .utf8_next_start_index = utf8_encoded_string_entity_end_index
    };
  return utf8_encoded_string_struct;
}

struct_utf8_string
get_utf8_encoded_string(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t utf8_encoded_string_start_index
)
{
  uint8_t msb_u8 = packet_data[utf8_encoded_string_start_index];
  uint8_t lsb_u8 = packet_data[utf8_encoded_string_start_index + (uint32_t)1U];
  uint8_t empty_buffer = (uint8_t)0U;
  uint16_t two_byte_integer = get_two_byte_integer_u8_to_u16(msb_u8, lsb_u8);
  if (msb_u8 == (uint8_t)0U && lsb_u8 == (uint8_t)0U)
    return
      (
        (struct_utf8_string){
          .utf8_string_length = (uint16_t)0U,
          .utf8_string_value = &empty_buffer,
          .utf8_string_status_code = (uint8_t)0U,
          .utf8_next_start_index = utf8_encoded_string_start_index + (uint32_t)2U
        }
      );
  else if
  (utf8_encoded_string_start_index + (uint32_t)two_byte_integer + (uint32_t)1U < max_packet_size)
  {
    struct_utf8_string
    utf8_encoded_string_struct =
      is_valid_utf8_encoded_string(packet_data,
        packet_size,
        utf8_encoded_string_start_index,
        two_byte_integer);
    return utf8_encoded_string_struct;
  }
  else
    return
      (
        (struct_utf8_string){
          .utf8_string_length = (uint16_t)0U,
          .utf8_string_value = &empty_buffer,
          .utf8_string_status_code = (uint8_t)1U,
          .utf8_next_start_index = (uint32_t)0U
        }
      );
}

struct_property_type
parse_property_utf8_encoded_string(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t property_value_start_index
)
{
  struct_property_type b = property_struct_type_base;
  struct_utf8_string
  utf8_encoded_string_struct =
    get_utf8_encoded_string(packet_data,
      packet_size,
      property_value_start_index);
  struct_property_error ite;
  if (utf8_encoded_string_struct.utf8_string_status_code == (uint8_t)0U)
    ite = define_struct_property_no_error;
  else
    ite = define_struct_property_utf8_encoded_string_error;
  struct_property_type
  property_struct_type_base1 =
    {
      .one_byte_integer_struct = b.one_byte_integer_struct,
      .two_byte_integer_struct = b.two_byte_integer_struct,
      .four_byte_integer_struct = b.four_byte_integer_struct,
      .utf8_encoded_string_struct = utf8_encoded_string_struct,
      .variable_byte_integer_struct = b.variable_byte_integer_struct,
      .binary_data_struct = {
        .is_valid_binary_data = b.binary_data_struct.is_valid_binary_data,
        .binary_length = b.binary_data_struct.binary_length,
        .binary_value = b.binary_data_struct.binary_value,
        .binary_next_start_index = b.binary_data_struct.binary_next_start_index
      },
      .utf8_string_pair_struct = {
        .utf8_string_pair_key = {
          .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_length,
          .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_value,
          .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_key.utf8_string_status_code,
          .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
        },
        .utf8_string_pair_value = {
          .utf8_string_length = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_length,
          .utf8_string_value = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_value,
          .utf8_string_status_code = b.utf8_string_pair_struct.utf8_string_pair_value.utf8_string_status_code,
          .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
        }
      }, .property_type_error = ite
    };
  return property_struct_type_base1;
}

struct_utf8_string_pair
get_utf8_encoded_string_pair(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t utf8_encoded_string_pair_start_index
)
{
  uint8_t fisrt_msb_u8 = packet_data[utf8_encoded_string_pair_start_index];
  uint8_t first_lsb_u8 = packet_data[utf8_encoded_string_pair_start_index + (uint32_t)1U];
  uint16_t fist_byte_integer = get_two_byte_integer_u8_to_u16(fisrt_msb_u8, first_lsb_u8);
  bool ptr_have_error = false;
  uint8_t second_msb_u8;
  if
  (
    utf8_encoded_string_pair_start_index
    + (uint32_t)fist_byte_integer
    + (uint32_t)2U
    < packet_size
  )
    second_msb_u8 =
      packet_data[utf8_encoded_string_pair_start_index
      + (uint32_t)fist_byte_integer
      + (uint32_t)2U];
  else
  {
    ptr_have_error = true;
    second_msb_u8 = (uint8_t)0U;
  }
  uint8_t second_lsb_u8;
  if
  (
    utf8_encoded_string_pair_start_index
    + (uint32_t)fist_byte_integer
    + (uint32_t)3U
    < packet_size
  )
    second_lsb_u8 =
      packet_data[utf8_encoded_string_pair_start_index
      + (uint32_t)fist_byte_integer
      + (uint32_t)3U];
  else
  {
    ptr_have_error = true;
    second_lsb_u8 = (uint8_t)0U;
  }
  uint32_t
  temp = utf8_encoded_string_pair_start_index + (uint32_t)fist_byte_integer + (uint32_t)2U;
  uint32_t next_utf8_encoded_string_start_index;
  if (temp < max_packet_size)
    next_utf8_encoded_string_start_index = temp;
  else
  {
    ptr_have_error = true;
    next_utf8_encoded_string_start_index = (uint32_t)0U;
  }
  uint16_t second_byte_integer = get_two_byte_integer_u8_to_u16(second_msb_u8, second_lsb_u8);
  bool have_error = ptr_have_error;
  uint8_t empty_buffer;
  if
  (
    have_error
    || utf8_encoded_string_pair_start_index + (uint32_t)2U >= max_packet_size
    ||
      utf8_encoded_string_pair_start_index
      + (uint32_t)fist_byte_integer
      + (uint32_t)1U
      >= max_packet_size
    || next_utf8_encoded_string_start_index + (uint32_t)2U >= max_packet_size
    ||
      next_utf8_encoded_string_start_index
      + (uint32_t)second_byte_integer
      + (uint32_t)1U
      >= max_packet_size
  )
  {
    empty_buffer = (uint8_t)0U;
    struct_utf8_string
    error_utf8 =
      {
        .utf8_string_length = (uint16_t)0U,
        .utf8_string_value = &empty_buffer,
        .utf8_string_status_code = (uint8_t)1U,
        .utf8_next_start_index = (uint32_t)0U
      };
    return
      (
        (struct_utf8_string_pair){
          .utf8_string_pair_key = error_utf8,
          .utf8_string_pair_value = error_utf8
        }
      );
  }
  else
  {
    struct_utf8_string
    utf8_string_pair_key =
      is_valid_utf8_encoded_string(packet_data,
        packet_size,
        utf8_encoded_string_pair_start_index,
        fist_byte_integer);
    struct_utf8_string
    utf8_string_pair_value =
      is_valid_utf8_encoded_string(packet_data,
        packet_size,
        next_utf8_encoded_string_start_index,
        second_byte_integer);
    return
      (
        (struct_utf8_string_pair){
          .utf8_string_pair_key = utf8_string_pair_key,
          .utf8_string_pair_value = utf8_string_pair_value
        }
      );
  }
}

struct_property_type
parse_property_utf8_encoded_string_pair(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t property_value_start_index
)
{
  struct_utf8_string_pair
  utf8_encoded_string_pair_struct =
    get_utf8_encoded_string_pair(packet_data,
      packet_size,
      property_value_start_index);
  struct_property_type b = property_struct_type_base;
  struct_property_error ite;
  if
  (
    utf8_encoded_string_pair_struct.utf8_string_pair_key.utf8_string_status_code
    == (uint8_t)1U
    ||
      utf8_encoded_string_pair_struct.utf8_string_pair_value.utf8_string_status_code
      == (uint8_t)1U
  )
    ite = define_struct_property_utf8_encoded_string_pair_error;
  else
    ite = define_struct_property_no_error;
  struct_property_type
  property_struct_type_base1 =
    {
      .one_byte_integer_struct = b.one_byte_integer_struct,
      .two_byte_integer_struct = b.two_byte_integer_struct,
      .four_byte_integer_struct = b.four_byte_integer_struct,
      .utf8_encoded_string_struct = {
        .utf8_string_length = b.utf8_encoded_string_struct.utf8_string_length,
        .utf8_string_value = b.utf8_encoded_string_struct.utf8_string_value,
        .utf8_string_status_code = b.utf8_encoded_string_struct.utf8_string_status_code,
        .utf8_next_start_index = b.utf8_encoded_string_struct.utf8_next_start_index
      }, .variable_byte_integer_struct = b.variable_byte_integer_struct,
      .binary_data_struct = {
        .is_valid_binary_data = b.binary_data_struct.is_valid_binary_data,
        .binary_length = b.binary_data_struct.binary_length,
        .binary_value = b.binary_data_struct.binary_value,
        .binary_next_start_index = b.binary_data_struct.binary_next_start_index
      }, .utf8_string_pair_struct = utf8_encoded_string_pair_struct, .property_type_error = ite
    };
  return property_struct_type_base1;
}

struct_property_type
get_property_type_struct(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint8_t property_type_id,
  uint32_t property_value_start_index
)
{
  if (property_type_id == (uint8_t)1U && property_value_start_index < packet_size)
    return parse_property_one_byte_integer(packet_data, packet_size, property_value_start_index);
  else if
  (property_type_id == (uint8_t)2U && property_value_start_index < packet_size - (uint32_t)1U)
    return parse_property_two_byte_integer(packet_data, packet_size, property_value_start_index);
  else if
  (
    property_type_id
    == (uint8_t)3U
    && packet_size > (uint32_t)3U
    && property_value_start_index < packet_size - (uint32_t)3U
  )
    return parse_property_four_byte_integer(packet_data, packet_size, property_value_start_index);
  else if
  (
    property_type_id
    == (uint8_t)4U
    && property_value_start_index < packet_size - (uint32_t)1U
    && property_value_start_index + (uint32_t)2U < max_packet_size
  )
    return
      parse_property_utf8_encoded_string(packet_data,
        packet_size,
        property_value_start_index);
  else if (property_type_id == (uint8_t)5U && property_value_start_index < packet_size)
    return
      parse_property_variable_byte_integer(packet_data,
        packet_size,
        property_value_start_index);
  else if
  (
    property_type_id
    == (uint8_t)6U
    && packet_size > (uint32_t)2U
    && property_value_start_index < packet_size - (uint32_t)2U
  )
    return parse_property_binary(packet_data, packet_size, property_value_start_index);
  else if
  (property_type_id == (uint8_t)7U && property_value_start_index < packet_size - (uint32_t)1U)
    return
      parse_property_utf8_encoded_string_pair(packet_data,
        packet_size,
        property_value_start_index);
  else
    return property_struct_type_base;
}

struct_property
parse_property(uint8_t *packet_data, uint32_t packet_size, uint32_t property_start_index)
{
  bool ptr_have_error = false;
  uint8_t first_property_length_byte = packet_data[property_start_index];
  if (first_property_length_byte == (uint8_t)0U)
  {
    struct_property
    property =
      {
        .property_id = (uint8_t)0U,
        .property_type_id = (uint8_t)0U,
        .property_type_struct = no_property_struct_type_base,
        .payload_start_index = property_start_index + (uint32_t)1U
      };
    return property;
  }
  else
  {
    struct_variable_length
    variable_length = get_variable_byte(packet_data, packet_size, property_start_index, true);
    uint32_t property_length = variable_length.variable_length_value;
    uint32_t property_id_start_index = variable_length.next_start_index;
    uint32_t temp_index0 = property_length + property_id_start_index;
    uint32_t last1;
    if (temp_index0 < max_packet_size)
      last1 = temp_index0;
    else
    {
      ptr_have_error = true;
      last1 = (uint32_t)0U;
    }
    uint8_t property_id;
    if (property_id_start_index < packet_size - (uint32_t)1U)
      property_id = packet_data[property_id_start_index];
    else
    {
      ptr_have_error = true;
      property_id = max_u8;
    }
    uint8_t property_type_id = get_property_type_id(property_id);
    uint32_t temp_index = property_id_start_index + (uint32_t)1U;
    uint32_t property_value_start_index;
    if (temp_index < max_packet_size)
      property_value_start_index = temp_index;
    else
    {
      ptr_have_error = true;
      property_value_start_index = (uint32_t)0U;
    }
    bool have_error = ptr_have_error;
    struct_property_type property_type_struct;
    if (!have_error)
      property_type_struct =
        get_property_type_struct(packet_data,
          packet_size,
          property_type_id,
          property_value_start_index);
    else
      property_type_struct = property_struct_type_base;
    return
      (
        (struct_property){
          .property_id = property_id,
          .property_type_id = property_type_id,
          .property_type_struct = property_type_struct,
          .payload_start_index = last1
        }
      );
  }
}

