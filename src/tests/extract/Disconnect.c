/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -verbose -warn-error +9 -drop WasmSupport -drop C_Endianness -drop C -tmpdir ../out -fsopt --cache_dir -fsopt ../out -no-prefix Main -no-prefix Utils -no-prefix Const -no-prefix Common -no-prefix Publish -no-prefix Connect -no-prefix Disconnect -no-prefix FFI -no-prefix Debug -no-prefix Debug_FFI -o ../mqttPacketParser.out main.fst common.fst const.fst publish.fst connect.fst disconnect.fst ffi.fst debug.fst debug_ffi.fst ffi.c debug_ffi.c callMain.c
  F* version: ad3db6d3
  KreMLin version: 2f843633
 */

#include "Disconnect.h"

struct_fixed_header assemble_disconnect_struct(struct_disconnect_parts s)
{
  struct_fixed_header_constant disconnect_constant = s.disconnect_disconnect_constant;
  uint8_t empty_buffer = (uint8_t)0U;
  return
    (
      (struct_fixed_header){
        .message_type = disconnect_constant.message_type_constant,
        .message_name = disconnect_constant.message_name_constant,
        .flags = {
          .flag = disconnect_constant.flags_constant.flag,
          .dup_flag = disconnect_constant.flags_constant.dup_flag,
          .qos_flag = disconnect_constant.flags_constant.qos_flag,
          .retain_flag = disconnect_constant.flags_constant.retain_flag
        },
        .remaining_length = s.disconnect_remaining_length,
        .connect = {
          .protocol_name = "", .protocol_version = max_u8,
          .flags = {
            .connect_flag = max_u8, .user_name = max_u8, .password = max_u8, .will_retain = max_u8,
            .will_qos = max_u8, .will_flag = max_u8, .clean_start = max_u8
          }, .keep_alive = (uint16_t)0U,
          .connect_id = {
            .utf8_string_length = (uint16_t)0U,
            .utf8_string_value = &empty_buffer,
            .utf8_string_status_code = (uint8_t)1U,
            .utf8_next_start_index = (uint32_t)0U
          },
          .will = {
            .connect_will_property = property_struct_base,
            .connect_will_topic_name = {
              .utf8_string_length = (uint16_t)0U,
              .utf8_string_value = &empty_buffer,
              .utf8_string_status_code = (uint8_t)1U,
              .utf8_next_start_index = (uint32_t)0U
            },
            .connect_will_payload = {
              .is_valid_binary_data = false,
              .binary_length = (uint16_t)0U,
              .binary_value = &empty_buffer,
              .binary_next_start_index = (uint32_t)0U
            },
            .user_name_or_password_next_start_index = (uint32_t)0U
          },
          .user_name = {
            .utf8_string_length = (uint16_t)0U,
            .utf8_string_value = &empty_buffer,
            .utf8_string_status_code = (uint8_t)1U,
            .utf8_next_start_index = (uint32_t)0U
          },
          .password = {
            .is_valid_binary_data = false,
            .binary_length = (uint16_t)0U,
            .binary_value = &empty_buffer,
            .binary_next_start_index = (uint32_t)0U
          }
        },
        .publish = {
          .topic_length = (uint32_t)0U,
          .topic_name = "",
          .packet_identifier = max_u16,
          .payload = {
            .is_valid_payload = false,
            .payload_value = &empty_buffer,
            .payload_length = (uint32_t)0U
          }
        },
        .disconnect = s.disconnect_struct,
        .property = s.property,
        .error = { .code = define_no_error_code, .message = define_no_error }
      }
    );
}

struct_disconnect_reason get_disconnect_reason(uint8_t reason_code)
{
  if (reason_code == define_disconnect_reason_code_normal_disconnection)
    return define_struct_disconnect_normal_disconnection;
  else if (reason_code == define_disconnect_reason_code_disconnect_with_will_message)
    return define_struct_disconnect_disconnect_with_will_message;
  else if (reason_code == define_disconnect_reason_code_unspecified_error)
    return define_struct_disconnect_unspecified_error;
  else if (reason_code == define_disconnect_reason_code_malformed_packet)
    return define_struct_disconnect_malformed_packet;
  else if (reason_code == define_disconnect_reason_code_protocol_error)
    return define_struct_disconnect_protocol_error;
  else if (reason_code == define_disconnect_reason_code_implementation_specific_error)
    return define_struct_disconnect_implementation_specific_error;
  else if (reason_code == define_disconnect_reason_code_not_authorized)
    return define_struct_disconnect_not_authorized;
  else if (reason_code == define_disconnect_reason_code_server_busy)
    return define_struct_disconnect_server_busy;
  else if (reason_code == define_disconnect_reason_code_server_shutting_down)
    return define_struct_disconnect_server_shutting_down;
  else if (reason_code == define_disconnect_reason_code_keep_alive_timeout)
    return define_struct_disconnect_keep_alive_timeout;
  else if (reason_code == define_disconnect_reason_code_session_taken_over)
    return define_struct_disconnect_session_taken_over;
  else if (reason_code == define_disconnect_reason_code_topic_filter_invalid)
    return define_struct_disconnect_topic_filter_invalid;
  else if (reason_code == define_disconnect_reason_code_topic_name_invalid)
    return define_struct_disconnect_topic_name_invalid;
  else if (reason_code == define_disconnect_reason_receive_maximum_exceeded)
    return define_struct_disconnect_receive_maximum_exceeded;
  else if (reason_code == define_disconnect_reason_topic_alias_invalid)
    return define_struct_disconnect_topic_alias_invalid;
  else if (reason_code == define_disconnect_reason_packet_too_large)
    return define_struct_disconnect_packet_too_large;
  else if (reason_code == define_disconnect_reason_message_rate_too_high)
    return define_struct_disconnect_message_rate_too_high;
  else if (reason_code == define_disconnect_reason_quota_exceeded)
    return define_struct_disconnect_quota_exceeded;
  else if (reason_code == define_disconnect_reason_administrative_action)
    return define_struct_disconnect_administrative_action;
  else if (reason_code == define_disconnect_reason_payload_format_invalid)
    return define_struct_disconnect_payload_format_invalid;
  else if (reason_code == define_disconnect_reason_retain_not_supported)
    return define_struct_disconnect_retain_not_supported;
  else if (reason_code == define_disconnect_reason_qos_not_supported)
    return define_struct_disconnect_qos_not_supported;
  else if (reason_code == define_disconnect_reason_use_another_server)
    return define_struct_disconnect_use_another_server;
  else if (reason_code == define_disconnect_reason_server_moved)
    return define_struct_disconnect_server_moved;
  else if (reason_code == define_disconnect_reason_shared_subscriptions_not_supported)
    return define_struct_disconnect_shared_subscriptions_not_supported;
  else if (reason_code == define_disconnect_reason_connection_rate_exceeded)
    return define_struct_disconnect_connection_rate_exceeded;
  else if (reason_code == define_disconnect_reason_maximum_connect_time)
    return define_struct_disconnect_maximum_connect_time;
  else if (reason_code == define_disconnect_reason_subscription_identifiers_not_supported)
    return define_struct_disconnect_subscription_identifiers_not_supported;
  else if (reason_code == define_disconnect_reason_wildcard_subscriptions_not_supported)
    return define_struct_disconnect_wildcard_subscriptions_not_supported;
  else
    return define_struct_disconnect_error;
}

struct_disconnect_packet_seed
disconnect_packet_parser(uint8_t *packet_data, uint32_t packet_size, uint32_t next_start_index)
{
  uint8_t reason_code = packet_data[next_start_index];
  struct_disconnect_reason disconnect_reason_struct = get_disconnect_reason(reason_code);
  uint32_t property_start_index = next_start_index + (uint32_t)1U;
  struct_property property_struct;
  if (property_start_index < packet_size - (uint32_t)1U)
    property_struct = parse_property(packet_data, packet_size, property_start_index);
  else
    property_struct =
      (
        (struct_property){
          .property_id = max_u8,
          .property_type_id = max_u8,
          .property_type_struct = property_struct_type_base,
          .payload_start_index = (uint32_t)0U
        }
      );
  return
    (
      (struct_disconnect_packet_seed){
        .disconnect_seed_reason = disconnect_reason_struct,
        .disconnect_seed_property = property_struct
      }
    );
}

struct_fixed_header disconnect_packet_parse_result(struct_share_common_data share_common_data)
{
  struct_fixed_header_constant
  disconnect_constant =
    get_struct_fixed_header_constant_except_publish(share_common_data.common_message_type);
  if (share_common_data.common_remaining_length == (uint32_t)0U)
  {
    struct_disconnect_reason disconnect_struct = define_struct_disconnect_normal_disconnection;
    struct_property
    no_property =
      {
        .property_id = (uint8_t)0U,
        .property_type_id = (uint8_t)0U,
        .property_type_struct = no_property_struct_type_base,
        .payload_start_index = (uint32_t)0U
      };
    struct_disconnect_parts
    ed_fixed_header_parts =
      {
        .disconnect_remaining_length = share_common_data.common_remaining_length,
        .disconnect_disconnect_constant = disconnect_constant,
        .disconnect_struct = disconnect_struct,
        .property = no_property
      };
    return assemble_disconnect_struct(ed_fixed_header_parts);
  }
  else if
  (
    share_common_data.common_next_start_index
    < share_common_data.common_packet_size - (uint32_t)1U
  )
  {
    struct_disconnect_packet_seed
    disconnect_packet_seed =
      disconnect_packet_parser(share_common_data.common_packet_data,
        share_common_data.common_packet_size,
        share_common_data.common_next_start_index);
    struct_disconnect_reason disconnect_reason = disconnect_packet_seed.disconnect_seed_reason;
    struct_property disconnect_property = disconnect_packet_seed.disconnect_seed_property;
    bool
    have_error =
      disconnect_reason.disconnect_reason_code
      == max_u8
      ||
        disconnect_property.property_type_struct.property_type_error.property_error_code
        > (uint8_t)0U;
    if (have_error)
    {
      struct_error_struct error_struct;
      if (disconnect_reason.disconnect_reason_code == max_u8)
        error_struct =
          (
            (struct_error_struct){
              .code = define_error_disconnect_reason_invalid_code,
              .message = define_error_disconnect_reason_invalid
            }
          );
      else
        error_struct =
          (
            (struct_error_struct){
              .code = define_error_property_error_code,
              .message = disconnect_property.property_type_struct.property_type_error.property_error_code_name
            }
          );
      return error_struct_fixed_header(error_struct);
    }
    else
    {
      struct_disconnect_reason disconnect_struct = disconnect_reason;
      struct_disconnect_parts
      ed_fixed_header_parts =
        {
          .disconnect_remaining_length = share_common_data.common_remaining_length,
          .disconnect_disconnect_constant = disconnect_constant,
          .disconnect_struct = disconnect_struct,
          .property = disconnect_property
        };
      return assemble_disconnect_struct(ed_fixed_header_parts);
    }
  }
  else
  {
    struct_error_struct
    error_struct =
      { .code = define_error_property_error_code, .message = define_error_property_invalid };
    return error_struct_fixed_header(error_struct);
  }
}

