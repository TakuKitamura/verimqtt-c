/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -verbose -warn-error +9 -drop WasmSupport -drop C_Endianness -drop C -tmpdir ../out -fsopt --cache_dir -fsopt ../out -no-prefix Main -no-prefix Utils -no-prefix Const -no-prefix Common -no-prefix Publish -no-prefix Connect -no-prefix Disconnect -no-prefix FFI -no-prefix Debug -no-prefix Debug_FFI -o ../mqttPacketParser.out main.fst common.fst const.fst publish.fst connect.fst disconnect.fst ffi.fst debug.fst debug_ffi.fst ffi.c debug_ffi.c callMain.c
  F* version: ad3db6d3
  KreMLin version: 2f843633
 */

#include "Publish.h"

struct_fixed_header_constant
struct_fixed_publish(uint8_t flag, uint8_t dup_flag, uint8_t qos_flag, uint8_t retain_flag)
{
  return
    (
      (struct_fixed_header_constant){
        .message_type_constant = define_mqtt_control_packet_PUBLISH,
        .message_name_constant = define_mqtt_control_packet_PUBLISH_label,
        .flags_constant = {
          .flag = flag,
          .dup_flag = dup_flag,
          .qos_flag = qos_flag,
          .retain_flag = retain_flag
        }
      }
    );
}

struct_fixed_header assemble_publish_struct(struct_publish_parts s)
{
  uint8_t empty_buffer = (uint8_t)0U;
  struct_fixed_header_constant
  data =
    struct_fixed_publish(s.publish_flag,
      s.publish_dup_flag,
      s.publish_qos_flag,
      s.publish_retain_flag);
  return
    (
      (struct_fixed_header){
        .message_type = data.message_type_constant,
        .message_name = data.message_name_constant,
        .flags = {
          .flag = data.flags_constant.flag,
          .dup_flag = data.flags_constant.dup_flag,
          .qos_flag = data.flags_constant.qos_flag,
          .retain_flag = data.flags_constant.retain_flag
        },
        .remaining_length = s.publish_remaining_length,
        .connect = {
          .protocol_name = "", .protocol_version = max_u8,
          .flags = {
            .connect_flag = max_u8, .user_name = max_u8, .password = max_u8, .will_retain = max_u8,
            .will_qos = max_u8, .will_flag = max_u8, .clean_start = max_u8
          }, .keep_alive = (uint16_t)0U,
          .connect_id = {
            .utf8_string_length = (uint16_t)0U,
            .utf8_string_value = &empty_buffer,
            .utf8_string_status_code = (uint8_t)1U,
            .utf8_next_start_index = (uint32_t)0U
          },
          .will = {
            .connect_will_property = property_struct_base,
            .connect_will_topic_name = {
              .utf8_string_length = (uint16_t)0U,
              .utf8_string_value = &empty_buffer,
              .utf8_string_status_code = (uint8_t)1U,
              .utf8_next_start_index = (uint32_t)0U
            },
            .connect_will_payload = {
              .is_valid_binary_data = false,
              .binary_length = (uint16_t)0U,
              .binary_value = &empty_buffer,
              .binary_next_start_index = (uint32_t)0U
            },
            .user_name_or_password_next_start_index = (uint32_t)0U
          },
          .user_name = {
            .utf8_string_length = (uint16_t)0U,
            .utf8_string_value = &empty_buffer,
            .utf8_string_status_code = (uint8_t)1U,
            .utf8_next_start_index = (uint32_t)0U
          },
          .password = {
            .is_valid_binary_data = false,
            .binary_length = (uint16_t)0U,
            .binary_value = &empty_buffer,
            .binary_next_start_index = (uint32_t)0U
          }
        },
        .publish = {
          .topic_length = s.publish_topic_length,
          .topic_name = s.publish_topic_name,
          .packet_identifier = s.publish_packet_identifier,
          .payload = s.publish_payload
        },
        .disconnect = { .disconnect_reason_code = max_u8, .disconnect_reason_code_name = "" },
        .property = s.publish_property,
        .error = { .code = define_no_error_code, .message = define_no_error }
      }
    );
}

struct_topic_name
get_topic_name(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint32_t topic_name_start_index,
  uint32_t topic_length
)
{
  uint32_t ptr_counter = (uint32_t)0U;
  uint8_t ptr_topic_name_u8[65536U] = { 0U };
  C_String_t ptr_topic_name = "";
  uint8_t ptr_topic_name_error_status = (uint8_t)0U;
  uint32_t last1 = topic_length + topic_name_start_index;
  if (topic_name_start_index <= last1)
    for (uint32_t i = topic_name_start_index; i < last1; i = i + (uint32_t)1U)
    {
      uint8_t one_byte;
      if (i < packet_size)
        one_byte = packet_data[i];
      else
      {
        ptr_topic_name_error_status = (uint8_t)1U;
        one_byte = max_u8;
      }
      if (one_byte == (uint8_t)0x00U || one_byte == (uint8_t)0x23U || one_byte == (uint8_t)0x2bU)
        ptr_topic_name_error_status = (uint8_t)2U;
      else
      {
        uint32_t counter = ptr_counter;
        if (counter < (uint32_t)65536U)
          ptr_topic_name_u8[counter] = one_byte;
        else
          ptr_topic_name_error_status = (uint8_t)1U;
        if (counter == topic_length - (uint32_t)1U)
        {
          C_String_t topic_name;
          if (ptr_topic_name_u8[65535U] == (uint8_t)0U)
            topic_name = uint8_to_c_string(ptr_topic_name_u8);
          else
          {
            ptr_topic_name_error_status = (uint8_t)1U;
            topic_name = "";
          }
          ptr_topic_name = topic_name;
        }
      }
      uint32_t counter = ptr_counter;
      if (counter < max_u32)
        ptr_counter = counter + (uint32_t)1U;
      else
        ptr_topic_name_error_status = (uint8_t)1U;
    }
  else
    ptr_topic_name_error_status = (uint8_t)1U;
  C_String_t topic_name = ptr_topic_name;
  uint8_t topic_name_error_status = ptr_topic_name_error_status;
  return
    (
      (struct_topic_name){
        .topic_name_error_status = topic_name_error_status,
        .topic_name = topic_name
      }
    );
}

struct_publish_packet_seed
publish_packet_parser(
  uint8_t *packet_data,
  uint32_t packet_size,
  uint8_t common_flag,
  uint32_t next_start_index
)
{
  uint8_t dup_flag = get_dup_flag(common_flag);
  uint8_t qos_flag = get_qos_flag(common_flag);
  uint8_t retain_flag = get_retain_flag(common_flag);
  uint8_t msb_u8 = packet_data[next_start_index];
  uint8_t lsb_u8 = packet_data[next_start_index + (uint32_t)1U];
  uint32_t msb_u32 = (uint32_t)msb_u8;
  uint32_t lsb_u32 = (uint32_t)lsb_u8;
  uint32_t temp_length = msb_u32 << (uint32_t)8U | lsb_u32;
  uint32_t topic_length;
  if (temp_length <= (uint32_t)65535U || temp_length == max_u32)
    topic_length = temp_length;
  else
    topic_length = max_u32;
  uint32_t topic_name_start_index = next_start_index + (uint32_t)2U;
  uint64_t temp0 = (uint64_t)topic_name_start_index + (uint64_t)topic_length;
  struct_topic_name topic_name_struct;
  if (temp0 <= (uint64_t)max_u32 && topic_name_start_index + topic_length <= max_u32)
    topic_name_struct =
      get_topic_name(packet_data,
        packet_size,
        topic_name_start_index,
        topic_length);
  else
    topic_name_struct =
      ((struct_topic_name){ .topic_name_error_status = (uint8_t)1U, .topic_name = "" });
  uint8_t topic_name_error_status = topic_name_struct.topic_name_error_status;
  uint64_t temp1 = (uint64_t)(next_start_index + (uint32_t)2U) + (uint64_t)topic_length;
  uint64_t temp2 = (uint64_t)(next_start_index + (uint32_t)3U) + (uint64_t)topic_length;
  struct_packet_identifier packet_identifier_struct;
  if (temp1 < (uint64_t)packet_size && temp2 < (uint64_t)packet_size && qos_flag > (uint8_t)0U)
  {
    uint16_t
    packet_identifier_value =
      get_two_byte_integer_u8_to_u16(packet_data[(uint32_t)temp1],
        packet_data[(uint32_t)temp2]);
    packet_identifier_struct =
      (
        (struct_packet_identifier){
          .packet_identifier_value = packet_identifier_value,
          .property_start_to_offset = (uint32_t)2U
        }
      );
  }
  else
    packet_identifier_struct =
      (
        (struct_packet_identifier){
          .packet_identifier_value = max_u16,
          .property_start_to_offset = (uint32_t)0U
        }
      );
  uint64_t
  temp =
    (uint64_t)next_start_index
    + (uint64_t)2U
    + (uint64_t)topic_length
    + (uint64_t)packet_identifier_struct.property_start_to_offset;
  uint32_t property_start_index;
  if (temp < (uint64_t)max_packet_size)
    property_start_index =
      next_start_index
      + (uint32_t)2U
      + topic_length
      + packet_identifier_struct.property_start_to_offset;
  else
    property_start_index = (uint32_t)0U;
  struct_property property_struct;
  if (property_start_index < packet_size - (uint32_t)1U)
    property_struct = parse_property(packet_data, packet_size, property_start_index);
  else
    property_struct =
      (
        (struct_property){
          .property_id = max_u8,
          .property_type_id = max_u8,
          .property_type_struct = property_struct_type_base,
          .payload_start_index = (uint32_t)0U
        }
      );
  uint32_t payload_start_index = property_struct.payload_start_index;
  uint32_t payload_end_index = packet_size - (uint32_t)1U;
  uint8_t empty_buffer = (uint8_t)0U;
  struct_payload payload_struct;
  if
  (
    payload_end_index
    >= payload_start_index
    && payload_end_index - payload_start_index + (uint32_t)1U <= max_u32
    && payload_start_index < max_packet_size
    && payload_start_index < packet_size
  )
    payload_struct = get_payload(packet_data, packet_size, payload_start_index, payload_end_index);
  else
    payload_struct =
      (
        (struct_payload){
          .is_valid_payload = false,
          .payload_value = &empty_buffer,
          .payload_length = (uint32_t)0U
        }
      );
  uint8_t payload_error_status;
  if (payload_struct.is_valid_payload == false)
    payload_error_status = (uint8_t)1U;
  else
    payload_error_status = (uint8_t)0U;
  return
    (
      (struct_publish_packet_seed){
        .publish_seed_dup_flag = dup_flag,
        .publish_seed_qos_flag = qos_flag,
        .publish_seed_retain_flag = retain_flag,
        .publish_seed_topic_length = topic_length,
        .publish_seed_topic_name = topic_name_struct.topic_name,
        .publish_seed_topic_name_error_status = topic_name_error_status,
        .publish_seed_packet_identifier = packet_identifier_struct.packet_identifier_value,
        .publish_seed_is_searching_property_length = false,
        .publish_seed_payload = payload_struct,
        .publish_seed_payload_error_status = payload_error_status,
        .publish_seed_property = property_struct
      }
    );
}

struct_fixed_header publish_packet_parse_result(struct_share_common_data share_common_data)
{
  struct_publish_packet_seed
  publish_packet_seed =
    publish_packet_parser(share_common_data.common_packet_data,
      share_common_data.common_packet_size,
      share_common_data.common_flag,
      share_common_data.common_next_start_index);
  bool
  have_error =
    publish_packet_seed.publish_seed_dup_flag
    == max_u8
    || publish_packet_seed.publish_seed_qos_flag == max_u8
    || publish_packet_seed.publish_seed_retain_flag == max_u8
    || publish_packet_seed.publish_seed_topic_length == max_u32
    || publish_packet_seed.publish_seed_topic_name_error_status == (uint8_t)1U
    || publish_packet_seed.publish_seed_topic_name_error_status == (uint8_t)2U
    || publish_packet_seed.publish_seed_is_searching_property_length
    || publish_packet_seed.publish_seed_payload_error_status > (uint8_t)0U
    ||
      publish_packet_seed.publish_seed_property.property_type_struct.property_type_error.property_error_code
      > (uint8_t)0U;
  if (have_error)
  {
    struct_error_struct error_struct;
    if (publish_packet_seed.publish_seed_dup_flag == max_u8)
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_dup_flag_invalid_code,
            .message = define_error_dup_flag_invalid
          }
        );
    else if (publish_packet_seed.publish_seed_qos_flag == max_u8)
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_qos_flag_invalid_code,
            .message = define_error_qos_flag_invalid
          }
        );
    else if (publish_packet_seed.publish_seed_retain_flag == max_u8)
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_retain_flag_invalid_code,
            .message = define_error_retain_flag_invalid
          }
        );
    else if (publish_packet_seed.publish_seed_topic_length == max_u32)
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_topic_length_invalid_code,
            .message = define_error_topic_length_invalid
          }
        );
    else if (publish_packet_seed.publish_seed_topic_name_error_status == (uint8_t)1U)
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_topic_name_dont_zero_terminated_code,
            .message = define_error_topic_name_dont_zero_terminated
          }
        );
    else if (publish_packet_seed.publish_seed_topic_name_error_status == (uint8_t)2U)
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_topic_name_have_inavlid_character_code,
            .message = define_error_topic_name_have_inavlid_character
          }
        );
    else if (publish_packet_seed.publish_seed_is_searching_property_length)
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_property_length_invalid_code,
            .message = define_error_property_length_invalid
          }
        );
    else
      error_struct =
        (
          (struct_error_struct){
            .code = define_error_property_error_code,
            .message = publish_packet_seed.publish_seed_property.property_type_struct.property_type_error.property_error_code_name
          }
        );
    return error_struct_fixed_header(error_struct);
  }
  else
  {
    struct_publish_parts
    ed_fixed_header_parts =
      {
        .publish_remaining_length = share_common_data.common_remaining_length,
        .publish_flag = share_common_data.common_flag,
        .publish_dup_flag = get_dup_flag(share_common_data.common_flag),
        .publish_qos_flag = get_qos_flag(share_common_data.common_flag),
        .publish_retain_flag = get_retain_flag(share_common_data.common_flag),
        .publish_topic_name = publish_packet_seed.publish_seed_topic_name,
        .publish_topic_length = publish_packet_seed.publish_seed_topic_length,
        .publish_packet_identifier = publish_packet_seed.publish_seed_packet_identifier,
        .publish_payload = publish_packet_seed.publish_seed_payload,
        .publish_property = publish_packet_seed.publish_seed_property
      };
    return assemble_publish_struct(ed_fixed_header_parts);
  }
}

